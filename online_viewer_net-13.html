<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Preator.io - 2.5D Edition</title>
  <!-- Include Socket.io from CDN -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      font-family: 'Press Start 2P', cursive;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      margin: 0;
      border: none;
      image-rendering: pixelated;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.8),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: perspective(1000px) rotateX(1deg);
      position: absolute;
      top: 0;
      left: 0;
    }
    .info {
      position: absolute;
      top: 15px;
      left: 15px;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      z-index: 10;
      background: linear-gradient(135deg, rgba(0, 20, 40, 0.9), rgba(0, 10, 20, 0.9));
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #4a9eff;
      box-shadow: 
        0 8px 32px rgba(74, 158, 255, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: translateZ(10px);
    }
    /* Power-up HUD */
    .powerup-hud {
      position: absolute;
      bottom: 15px;
      left: 15px;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      z-index: 10;
      background: linear-gradient(135deg, rgba(40, 0, 40, 0.9), rgba(20, 0, 20, 0.9));
      padding: 15px;
      border-radius: 8px;
      border: 2px solid #ff4aff;
      box-shadow: 
        0 8px 32px rgba(255, 74, 255, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
    }
    /* Home Menu overlay */
    #homeMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.95), rgba(26, 26, 46, 0.95));
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      flex-direction: column;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      text-align: center;
    }
    #homeMenu h1 {
      text-shadow: 
        0 0 20px #4a9eff,
        0 0 40px #4a9eff,
        0 4px 8px rgba(0, 0, 0, 0.8);
      margin-bottom: 10px;
      transform: perspective(500px) rotateX(15deg);
    }
    #homeMenu h2 {
      color: #ff6b6b;
      text-shadow: 
        0 0 15px #ff6b6b,
        0 2px 4px rgba(0, 0, 0, 0.8);
      margin-bottom: 30px;
    }
    #homeMenu input {
      padding: 12px 20px;
      font-size: 14px;
      margin: 15px 0;
      text-align: center;
      background: linear-gradient(135deg, rgba(20, 20, 40, 0.9), rgba(10, 10, 30, 0.9));
      border: 2px solid #4a9eff;
      border-radius: 8px;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      box-shadow: 
        0 4px 15px rgba(74, 158, 255, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
    }
    #homeMenu button {
      padding: 15px 30px;
      font-size: 16px;
      margin-top: 20px;
      cursor: pointer;
      background: linear-gradient(135deg, #4a9eff, #357abd);
      color: #fff;
      border: 2px solid #6bb6ff;
      border-radius: 8px;
      font-family: 'Press Start 2P', cursive;
      box-shadow: 
        0 8px 25px rgba(74, 158, 255, 0.4),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
      transition: all 0.3s ease;
    }
    #homeMenu button:hover {
      transform: translateY(-4px);
      box-shadow: 
        0 12px 35px rgba(74, 158, 255, 0.6),
        inset 0 2px 4px rgba(255, 255, 255, 0.4);
    }
    #homeMenu button:active {
      transform: translateY(0px);
      box-shadow: 
        0 4px 15px rgba(74, 158, 255, 0.4),
        inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    /* Leaderboard styling (top 5 players) */
    #leaderboard {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      z-index: 10;
      background: linear-gradient(135deg, rgba(20, 40, 20, 0.9), rgba(10, 30, 10, 0.9));
      padding: 15px;
      border: 2px solid #4eff4a;
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 
        0 8px 32px rgba(78, 255, 74, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: translateX(-50%) perspective(800px) rotateX(5deg);
    }
    /* Chat styling */
    #chatContainer {
      position: absolute;
      bottom: 15px;
      right: 15px;
      width: 320px;
      max-height: 220px;
      background: linear-gradient(135deg, rgba(40, 20, 40, 0.9), rgba(30, 10, 30, 0.9));
      padding: 15px;
      font-family: 'Press Start 2P', cursive;
      color: #fff;
      overflow-y: auto;
      z-index: 30;
      border: 2px solid #ff4a9e;
      border-radius: 8px;
      box-shadow: 
        0 8px 32px rgba(255, 74, 158, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: perspective(600px) rotateY(-5deg);
    }
    #chatInput {
      width: calc(100% - 24px);
      padding: 8px 12px;
      font-size: 12px;
      margin-top: 8px;
      box-sizing: border-box;
      background: linear-gradient(135deg, rgba(20, 10, 20, 0.9), rgba(10, 5, 10, 0.9));
      border: 2px solid #ff4a9e;
      border-radius: 6px;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    /* Emote styling */
    #emoteContainer {
      position: absolute;
      bottom: 80px;
      right: 15px;
      background: linear-gradient(135deg, rgba(40, 40, 20, 0.9), rgba(30, 30, 10, 0.9));
      padding: 10px;
      z-index: 30;
      border: 2px solid #ffff4a;
      border-radius: 8px;
      box-shadow: 
        0 8px 25px rgba(255, 255, 74, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: perspective(500px) rotateZ(-2deg);
    }
    #emoteContainer button {
      background: linear-gradient(135deg, rgba(60, 60, 30, 0.8), rgba(40, 40, 20, 0.8));
      border: 2px solid #ffff4a;
      border-radius: 6px;
      font-size: 20px;
      cursor: pointer;
      margin: 2px;
      padding: 8px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(255, 255, 74, 0.2);
    }
    #emoteContainer button:hover {
      transform: translateY(-2px) scale(1.1);
      box-shadow: 0 6px 18px rgba(255, 255, 74, 0.4);
    }
    /* Minimap styling */
    .minimap {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 220px;
      height: 220px;
      border: 3px solid #666;
      border-radius: 8px;
      background: linear-gradient(135deg, #333, #222);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.6),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      transform: perspective(800px) rotateY(5deg) rotateX(-5deg);
    }
    .minimap canvas {
      width: 100%;
      height: 100%;
      border-radius: 5px;
    }
    .minimap::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(45deg, #4a9eff, #ff4a9e, #4eff4a, #ffff4a);
      border-radius: 8px;
      z-index: -1;
      opacity: 0.3;
      animation: glow 3s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from { opacity: 0.2; }
      to { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <!-- Home Menu -->
  <div id="homeMenu">
    <h1>Preator.io</h1>
    <h2>2.5D Edition</h2>
    <input type="text" id="playerNameInput" placeholder="Enter your name" />
    <p>Use ARROW keys to move. Dash with Shift.</p>
    <p>Collect food to grow and consume enemies.</p>
    <p>Spacebar to shoot when you have ammo!</p>
    <p>Chat with others online while playing against smart bots!</p>
    <button id="startButton">Start Game</button>
  </div>

  <div class="info">
    <p><strong>Preator.io</strong></p>
    <p>2.5D Edition</p>
  </div>

  <div class="powerup-hud">
    <p id="ammoCount">Ammo: 0</p>
    <p id="powerupStatus">No Power-ups</p>
  </div>

  <canvas id="gameCanvas"></canvas>
  <div class="minimap">
    <canvas id="minimapCanvas"></canvas>
  </div>
  
  <!-- Leaderboard (top 5 players) -->
  <div id="leaderboard"></div>
  
  <!-- Chat container -->
  <div id="chatContainer">
    <div id="chatLog"></div>
    <input type="text" id="chatInput" placeholder="Type a message and press Enter" />
  </div>
  
  <!-- Emote container -->
  <div id="emoteContainer">
    <button class="emoteBtn">üòÄ</button>
    <button class="emoteBtn">üò¢</button>
    <button class="emoteBtn">üòé</button>
    <button class="emoteBtn">üòÆ</button>
    <button class="emoteBtn">‚ù§Ô∏è</button>
  </div>
  
  <script>
    window.addEventListener('DOMContentLoaded', () => {

      /* ----------------- Sprite/Texture Generation ----------------- */
      function createBackgroundSprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 32;
        offCanvas.height = 32;
        const offCtx = offCanvas.getContext('2d');
        offCtx.fillStyle = '#00aa00';
        offCtx.fillRect(0, 0, 32, 32);
        offCtx.fillStyle = '#885522';
        offCtx.fillRect(4, 4, 4, 4);
        offCtx.fillRect(20, 10, 4, 4);
        offCtx.fillRect(10, 20, 4, 4);
        return offCanvas.toDataURL();
      }
      
      function createEnemySprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 40;
        offCanvas.height = 40;
        const offCtx = offCanvas.getContext('2d');
        
        // Shadow
        offCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        offCtx.fillRect(6, 34, 28, 4);
        
        // Main body with gradient
        const gradient = offCtx.createLinearGradient(0, 0, 0, 32);
        gradient.addColorStop(0, '#ff4444');
        gradient.addColorStop(0.5, '#ff0000');
        gradient.addColorStop(1, '#cc0000');
        offCtx.fillStyle = gradient;
        offCtx.fillRect(6, 10, 24, 24);
        
        // Top highlight
        offCtx.fillStyle = '#ff8888';
        offCtx.beginPath();
        offCtx.moveTo(6, 10);
        offCtx.lineTo(10, 6);
        offCtx.lineTo(34, 6);
        offCtx.lineTo(30, 10);
        offCtx.closePath();
        offCtx.fill();
        
        // Right shadow
        offCtx.fillStyle = '#880000';
        offCtx.beginPath();
        offCtx.moveTo(30, 10);
        offCtx.lineTo(34, 6);
        offCtx.lineTo(34, 30);
        offCtx.lineTo(30, 34);
        offCtx.closePath();
        offCtx.fill();
        
        // Menacing eyes with red glow
        offCtx.fillStyle = '#ff0000';
        offCtx.shadowColor = '#ff0000';
        offCtx.shadowBlur = 3;
        offCtx.fillRect(12, 18, 4, 4);
        offCtx.fillRect(20, 18, 4, 4);
        offCtx.shadowBlur = 0;
        
        // Angry mouth
        offCtx.fillStyle = '#440000';
        offCtx.fillRect(12, 26, 12, 2);
        
        return offCanvas.toDataURL();
      }
      
      function createPlayerSprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 40;
        offCanvas.height = 40;
        const offCtx = offCanvas.getContext('2d');
        
        // Shadow
        offCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        offCtx.fillRect(6, 34, 28, 4);
        
        // Main body with gradient effect
        const gradient = offCtx.createLinearGradient(0, 0, 0, 32);
        gradient.addColorStop(0, '#4466ff');
        gradient.addColorStop(0.5, '#0044ff');
        gradient.addColorStop(1, '#002299');
        offCtx.fillStyle = gradient;
        offCtx.fillRect(6, 10, 24, 24);
        
        // Top highlight
        offCtx.fillStyle = '#88aaff';
        offCtx.beginPath();
        offCtx.moveTo(6, 10);
        offCtx.lineTo(10, 6);
        offCtx.lineTo(34, 6);
        offCtx.lineTo(30, 10);
        offCtx.closePath();
        offCtx.fill();
        
        // Right shadow
        offCtx.fillStyle = '#001155';
        offCtx.beginPath();
        offCtx.moveTo(30, 10);
        offCtx.lineTo(34, 6);
        offCtx.lineTo(34, 30);
        offCtx.lineTo(30, 34);
        offCtx.closePath();
        offCtx.fill();
        
        // Eyes with glow
        offCtx.fillStyle = '#ffffff';
        offCtx.shadowColor = '#ffffff';
        offCtx.shadowBlur = 2;
        offCtx.fillRect(12, 18, 4, 4);
        offCtx.fillRect(20, 18, 4, 4);
        offCtx.shadowBlur = 0;
        
        // Mouth
        offCtx.fillStyle = '#ffffff';
        offCtx.fillRect(12, 26, 12, 2);
        
        return offCanvas.toDataURL();
      }
      
      function createFoodSprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 20;
        offCanvas.height = 20;
        const offCtx = offCanvas.getContext('2d');
        
        // Shadow
        offCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        offCtx.fillRect(2, 16, 16, 2);
        
        // Main food body with golden gradient
        const gradient = offCtx.createRadialGradient(10, 8, 2, 10, 8, 8);
        gradient.addColorStop(0, '#ffeb3b');
        gradient.addColorStop(0.7, '#ffc107');
        gradient.addColorStop(1, '#ff8f00');
        offCtx.fillStyle = gradient;
        offCtx.beginPath();
        offCtx.arc(10, 10, 8, 0, Math.PI * 2);
        offCtx.fill();
        
        // Highlight
        offCtx.fillStyle = '#fff59d';
        offCtx.beginPath();
        offCtx.arc(8, 8, 3, 0, Math.PI * 2);
        offCtx.fill();
        
        // Sparkle effect
        offCtx.fillStyle = '#ffffff';
        offCtx.shadowColor = '#ffeb3b';
        offCtx.shadowBlur = 2;
        offCtx.fillRect(6, 6, 1, 1);
        offCtx.fillRect(13, 8, 1, 1);
        offCtx.fillRect(9, 13, 1, 1);
        offCtx.shadowBlur = 0;
        
        return offCanvas.toDataURL();
      }

      function createPowerupSprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 24;
        offCanvas.height = 24;
        const offCtx = offCanvas.getContext('2d');
        
        // Pulsing glow effect
        const gradient = offCtx.createRadialGradient(12, 12, 4, 12, 12, 12);
        gradient.addColorStop(0, '#ff00ff');
        gradient.addColorStop(0.5, '#ff44ff');
        gradient.addColorStop(1, '#aa00aa');
        offCtx.fillStyle = gradient;
        offCtx.beginPath();
        offCtx.arc(12, 12, 10, 0, Math.PI * 2);
        offCtx.fill();
        
        // Inner core
        offCtx.fillStyle = '#ffffff';
        offCtx.beginPath();
        offCtx.arc(12, 12, 6, 0, Math.PI * 2);
        offCtx.fill();
        
        // Weapon symbol
        offCtx.fillStyle = '#ff00ff';
        offCtx.fillRect(10, 8, 4, 8);
        offCtx.fillRect(8, 10, 8, 4);
        
        return offCanvas.toDataURL();
      }

      function createProjectileSprite() {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = 12;
        offCanvas.height = 12;
        const offCtx = offCanvas.getContext('2d');
        
        // Glowing projectile
        const gradient = offCtx.createRadialGradient(6, 6, 2, 6, 6, 6);
        gradient.addColorStop(0, '#00ffff');
        gradient.addColorStop(0.7, '#0088ff');
        gradient.addColorStop(1, '#0044aa');
        offCtx.fillStyle = gradient;
        offCtx.beginPath();
        offCtx.arc(6, 6, 5, 0, Math.PI * 2);
        offCtx.fill();
        
        return offCanvas.toDataURL();
      }
      
      const backgroundImage = new Image();
      backgroundImage.src = createBackgroundSprite();
      const enemySprite = new Image();
      enemySprite.src = createEnemySprite();
      const playerSprite = new Image();
      playerSprite.src = createPlayerSprite();
      const foodSprite = new Image();
      foodSprite.src = createFoodSprite();
      const powerupSprite = new Image();
      powerupSprite.src = createPowerupSprite();
      const projectileSprite = new Image();
      projectileSprite.src = createProjectileSprite();
      
      /* -------------------------- Game Setup -------------------------- */
      const canvas = document.getElementById('gameCanvas');
      const minimapCanvas = document.getElementById('minimapCanvas');
      const ctx = canvas.getContext('2d');
      const minimapCtx = minimapCanvas.getContext('2d');
      
      // Make game fullscreen
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;
      }
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      let gameState = "menu"; // "menu", "playing", or "spectator"
      let gameLoopId = null;
      let spectatorTarget = null;
      
      // Local player object
      let player = {
        x: 3000 / 2,
        y: 3000 / 2,
        radius: 16,
        color: 'blue',
        speed: 3,
        dashSpeed: 10,
        dashDuration: 750,
        dashCooldown: 15000,
        isDashing: false,
        dashStart: 0,
        reloadTimeStart: 0,
        currentEmote: null,
        emoteTimestamp: 0,
        alive: true,
        ammo: 0,
        lastDirection: { x: 1, y: 0 }
      };
      
      let foods = [];
      const foodCount = 50;
      let enemies = [];
      const enemyCount = 20;
      const enemyNames = ["Gorg", "Zar", "Blip", "Fang", "Snarl", "Murk", "Snik", "Drak", "Vex", "Raze"];
      let powerups = [];
      let projectiles = [];
      let score = 0;
      let playerName = "Player";
      
      // Socket.io connection (fallback to local gameplay if server unavailable)
      let socket = null;
      let remotePlayers = {};
      
      try {
        socket = io();
        
        socket.on('connect', () => {
          console.log('Connected to server');
        });
        
        socket.on('playerUpdate', (data) => {
          remotePlayers[data.id] = data;
          updateLeaderboardUI();
        });
        
        socket.on('playerDisconnected', (id) => {
          delete remotePlayers[id];
          updateLeaderboardUI();
        });
        
        socket.on('chatMessage', (data) => {
          addChatMessage(data.name, data.message);
        });
        
        socket.on('gameStateUpdate', (data) => {
          foods = data.foods || foods;
          enemies = data.enemies || enemies;
          powerups = data.powerups || powerups;
          projectiles = data.projectiles || projectiles;
        });
        
      } catch (error) {
        console.log('Playing in offline mode');
      }
      
      function generateFood() {
        for (let i = 0; i < foodCount; i++) {
          foods.push({
            x: Math.random() * 3000,
            y: Math.random() * 3000,
            radius: 8,
            color: 'green',
            eaten: false
          });
        }
      }
      
      function generateEnemies() {
        for (let i = 0; i < enemyCount; i++) {
          enemies.push({
            x: Math.random() * 3000,
            y: Math.random() * 3000,
            radius: 16,
            color: 'red',
            speed: 2 + Math.random(),
            direction: Math.random() * 2 * Math.PI,
            detectionRadius: 155 + Math.random() * 50,
            wanderStart: Date.now(),
            name: enemyNames[Math.floor(Math.random() * enemyNames.length)],
            aggressionLevel: Math.random(),
            memory: [],
            lastPlayerSeen: null,
            huntMode: false,
            fleeMode: false,
            teamUp: null
          });
        }
      }
      
      function generatePowerups() {
        if (powerups.length < 3) {
          powerups.push({
            x: Math.random() * 3000,
            y: Math.random() * 3000,
            radius: 12,
            type: 'shooter',
            collected: false
          });
        }
      }
      
      generateFood();
      generateEnemies();
      setInterval(generatePowerups, 15000);
      
      let camera = { x: 0, y: 0, zoom: 1 };
      
      /* ------------------ Enhanced Enemy AI ------------------ */
      function updateEnemyAI() {
        for (let enemy of enemies) {
          const now = Date.now();
          
          // Enhanced memory system
          if (enemy.memory.length > 10) enemy.memory.shift();
          
          // Detect nearby entities
          let nearbyEnemies = enemies.filter(e => e !== enemy && 
            Math.hypot(e.x - enemy.x, e.y - enemy.y) < enemy.detectionRadius);
          let nearbyFood = foods.filter(f => 
            Math.hypot(f.x - enemy.x, f.y - enemy.y) < enemy.detectionRadius);
          let nearbyPowerups = powerups.filter(p => 
            Math.hypot(p.x - enemy.x, p.y - enemy.y) < enemy.detectionRadius);
          
          // Player detection
          let playerInRange = player.alive && 
            Math.hypot(player.x - enemy.x, player.y - enemy.y) < enemy.detectionRadius;
          
          if (playerInRange) {
            enemy.lastPlayerSeen = { x: player.x, y: player.y, time: now };
          }
          
          // Determine enemy behavior
          let shouldFlee = false;
          let shouldHunt = false;
          let target = null;
          
          // Check if should flee from larger enemies or player
          if (playerInRange && player.radius > enemy.radius * 1.2) {
            shouldFlee = true;
            enemy.fleeMode = true;
            target = { x: player.x, y: player.y };
          }
          
          for (let other of nearbyEnemies) {
            if (other.radius > enemy.radius * 1.3) {
              shouldFlee = true;
              enemy.fleeMode = true;
              target = other;
              break;
            }
          }
          
          // Hunt smaller enemies or player
          if (!shouldFlee) {
            if (playerInRange && enemy.radius > player.radius * 1.1) {
              shouldHunt = true;
              enemy.huntMode = true;
              target = { x: player.x, y: player.y };
            } else {
              for (let other of nearbyEnemies) {
                if (enemy.radius > other.radius * 1.1) {
                  shouldHunt = true;
                  enemy.huntMode = true;
                  target = other;
                  break;
                }
              }
            }
          }
          
          // Team up behavior for similar sized enemies
          if (!shouldFlee && !shouldHunt && enemy.aggressionLevel > 0.7) {
            let teammate = nearbyEnemies.find(e => 
              Math.abs(e.radius - enemy.radius) < 5 && e.aggressionLevel > 0.6);
            if (teammate) {
              enemy.teamUp = teammate;
            }
          }
          
          // Movement logic
          let moveX = 0, moveY = 0;
          
          if (shouldFlee && target) {
            // Flee with some randomness
            let fleeAngle = Math.atan2(enemy.y - target.y, enemy.x - target.x);
            fleeAngle += (Math.random() - 0.5) * 0.5; // Add some chaos
            moveX = Math.cos(fleeAngle) * enemy.speed * 1.5;
            moveY = Math.sin(fleeAngle) * enemy.speed * 1.5;
            enemy.memory.push({ action: 'flee', target: target, time: now });
          } else if (shouldHunt && target) {
            // Hunt with prediction
            let huntAngle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
            // Predict target movement
            if (enemy.memory.length > 2) {
              let lastPos = enemy.memory[enemy.memory.length - 1];
              if (lastPos.target) {
                let predictedX = target.x + (target.x - lastPos.target.x) * 2;
                let predictedY = target.y + (target.y - lastPos.target.y) * 2;
                huntAngle = Math.atan2(predictedY - enemy.y, predictedX - enemy.x);
              }
            }
            moveX = Math.cos(huntAngle) * enemy.speed * 1.2;
            moveY = Math.sin(huntAngle) * enemy.speed * 1.2;
            enemy.memory.push({ action: 'hunt', target: target, time: now });
          } else if (nearbyPowerups.length > 0) {
            // Go for powerups
            let closestPowerup = nearbyPowerups.reduce((closest, p) => {
              let dist = Math.hypot(p.x - enemy.x, p.y - enemy.y);
              return dist < closest.dist ? { powerup: p, dist: dist } : closest;
            }, { powerup: null, dist: Infinity });
            
            if (closestPowerup.powerup) {
              let angle = Math.atan2(closestPowerup.powerup.y - enemy.y, closestPowerup.powerup.x - enemy.x);
              moveX = Math.cos(angle) * enemy.speed;
              moveY = Math.sin(angle) * enemy.speed;
            }
          } else if (nearbyFood.length > 0) {
            // Go for food
            let closestFood = nearbyFood.reduce((closest, f) => {
              let dist = Math.hypot(f.x - enemy.x, f.y - enemy.y);
              return dist < closest.dist ? { food: f, dist: dist } : closest;
            }, { food: null, dist: Infinity });
            
            if (closestFood.food) {
              let angle = Math.atan2(closestFood.food.y - enemy.y, closestFood.food.x - enemy.x);
              moveX = Math.cos(angle) * enemy.speed;
              moveY = Math.sin(angle) * enemy.speed;
            }
          } else if (enemy.teamUp) {
            // Follow teammate
            let angle = Math.atan2(enemy.teamUp.y - enemy.y, enemy.teamUp.x - enemy.x);
            moveX = Math.cos(angle) * enemy.speed * 0.8;
            moveY = Math.sin(angle) * enemy.speed * 0.8;
          } else {
            // Wander with some persistence
            if (now - enemy.wanderStart > 3000 + Math.random() * 4000) {
              enemy.direction = Math.random() * 2 * Math.PI;
              enemy.wanderStart = now;
            }
            moveX = Math.cos(enemy.direction) * enemy.speed;
            moveY = Math.sin(enemy.direction) * enemy.speed;
          }
          
          // Apply movement with boundary checking
          enemy.x = Math.max(enemy.radius, Math.min(3000 - enemy.radius, enemy.x + moveX));
          enemy.y = Math.max(enemy.radius, Math.min(3000 - enemy.radius, enemy.y + moveY));
          
          // Reset modes periodically
          if (now - enemy.wanderStart > 8000) {
            enemy.huntMode = false;
            enemy.fleeMode = false;
            enemy.teamUp = null;
          }
        }
      }
      
      /* ------------------ Input Handling ------------------ */
      let keys = {};
      window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        
        // Shooting
        if (e.code === 'Space' && player.ammo > 0 && gameState === "playing") {
          e.preventDefault();
          shootProjectile();
        }
        
        // In spectator mode, pressing "M" returns to the menu.
        if (gameState === "spectator" && e.key.toLowerCase() === 'm') {
          cancelAnimationFrame(gameLoopId);
          gameLoopId = null;
          gameState = "menu";
          document.getElementById('homeMenu').style.display = 'flex';
          keys = {};
        }
      });
      
      window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
      });
      
      function shootProjectile() {
        if (player.ammo <= 0) return;
        
        player.ammo--;
        updatePowerupHUD();
        
        let angle = Math.atan2(player.lastDirection.y, player.lastDirection.x);
        
        projectiles.push({
          x: player.x + Math.cos(angle) * player.radius,
          y: player.y + Math.sin(angle) * player.radius,
          vx: Math.cos(angle) * 8,
          vy: Math.sin(angle) * 8,
          radius: 6,
          owner: 'player',
          damage: 10,
          life: 100
        });
        
        if (socket) {
          socket.emit('projectileFired', {
            x: player.x,
            y: player.y,
            angle: angle,
            owner: playerName
          });
        }
      }
      
      function handleDash() {
        const now = Date.now();
        if (keys['Shift'] && !player.isDashing && now - player.reloadTimeStart >= player.dashCooldown) {
          player.isDashing = true;
          player.dashStart = now;
          player.reloadTimeStart = now;
          setTimeout(() => { player.isDashing = false; }, player.dashDuration);
        }
      }
      
      function movePlayer() {
        const speed = player.isDashing ? player.dashSpeed : player.speed;
        let moved = false;
        
        if (keys['ArrowUp']) {
          player.y -= speed;
          player.lastDirection = { x: 0, y: -1 };
          moved = true;
        }
        if (keys['ArrowDown']) {
          player.y += speed;
          player.lastDirection = { x: 0, y: 1 };
          moved = true;
        }
        if (keys['ArrowLeft']) {
          player.x -= speed;
          player.lastDirection = { x: -1, y: 0 };
          moved = true;
        }
        if (keys['ArrowRight']) {
          player.x += speed;
          player.lastDirection = { x: 1, y: 0 };
          moved = true;
        }
        
        player.x = Math.max(player.radius, Math.min(3000 - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(3000 - player.radius, player.y));
        
        if (moved && socket) {
          socket.emit('playerMove', {
            x: player.x,
            y: player.y,
            radius: player.radius,
            name: playerName,
            alive: player.alive,
            score: score
          });
        }
      }
      
      function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          let proj = projectiles[i];
          
          proj.x += proj.vx;
          proj.y += proj.vy;
          proj.life--;
          
          // Remove if out of bounds or life expired
          if (proj.x < 0 || proj.x > 3000 || proj.y < 0 || proj.y > 3000 || proj.life <= 0) {
            projectiles.splice(i, 1);
            continue;
          }
          
          // Check collisions with enemies
          for (let j = enemies.length - 1; j >= 0; j--) {
            let enemy = enemies[j];
            let dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
            
            if (dist < proj.radius + enemy.radius) {
              // Hit enemy
              enemy.radius = Math.max(10, enemy.radius - proj.damage);
              projectiles.splice(i, 1);
              
              if (enemy.radius <= 10) {
                score += 100;
                enemies.splice(j, 1);
                // Respawn enemy after delay
                setTimeout(() => {
                  enemies.push({
                    x: Math.random() * 3000,
                    y: Math.random() * 3000,
                    radius: 16,
                    color: 'red',
                    speed: 2 + Math.random(),
                    direction: Math.random() * 2 * Math.PI,
                    detectionRadius: 155 + Math.random() * 50,
                    wanderStart: Date.now(),
                    name: enemyNames[Math.floor(Math.random() * enemyNames.length)],
                    aggressionLevel: Math.random(),
                    memory: [],
                    lastPlayerSeen: null,
                    huntMode: false,
                    fleeMode: false,
                    teamUp: null
                  });
                }, 3000);
              }
              break;
            }
          }
        }
      }
      
      function detectPlayerCollisions() {
        // Collisions with food
        for (let i = 0; i < foods.length; i++) {
          const food = foods[i];
          const dx = player.x - food.x;
          const dy = player.y - food.y;
          const distance = Math.hypot(dx, dy);
          if (distance < player.radius + food.radius) {
            player.radius += 1;
            score += 10;
            foods.splice(i, 1);
            i--;
            setTimeout(() => {
              foods.push({
                x: Math.random() * 3000,
                y: Math.random() * 3000,
                radius: 8,
                color: 'green',
                eaten: false
              });
            }, 5000);
          }
        }
        
        // Collisions with powerups
        for (let i = 0; i < powerups.length; i++) {
          const powerup = powerups[i];
          const dx = player.x - powerup.x;
          const dy = player.y - powerup.y;
          const distance = Math.hypot(dx, dy);
          if (distance < player.radius + powerup.radius) {
            if (powerup.type === 'shooter') {
              player.ammo += 10;
              updatePowerupHUD();
            }
            powerups.splice(i, 1);
            i--;
            score += 25;
          }
        }
        
        // Collisions with enemies
        for (let i = 0; i < enemies.length; i++) {
          const enemy = enemies[i];
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const distance = Math.hypot(dx, dy);
          if (distance < player.radius + enemy.radius) {
            if (enemy.radius > player.radius) {
              // Player dies
              player.alive = false;
              spectatorTarget = enemy;
              gameState = "spectator";
              if (socket) {
                socket.emit('playerDied', { name: playerName });
              }
              return;
            } else {
              player.radius += 2;
              score += 50;
              enemies.splice(i, 1);
              i--;
              setTimeout(() => {
                enemies.push({
                  x: Math.random() * 3000,
                  y: Math.random() * 3000,
                  radius: 16,
                  color: 'red',
                  speed: 2 + Math.random(),
                  direction: Math.random() * 2 * Math.PI,
                  detectionRadius: 155 + Math.random() * 50,
                  wanderStart: Date.now(),
                  name: enemyNames[Math.floor(Math.random() * enemyNames.length)],
                  aggressionLevel: Math.random(),
                  memory: [],
                  lastPlayerSeen: null,
                  huntMode: false,
                  fleeMode: false,
                  teamUp: null
                });
              }, 5000);
            }
          }
        }
      }
      
      // Enemies eat food and each other with enhanced AI
      function simulateEnemyConsumption() {
        for (let i = 0; i < enemies.length; i++) {
          const enemy = enemies[i];
          
          // Eat food
          for (let j = 0; j < foods.length; j++) {
            const food = foods[j];
            const dx = enemy.x - food.x;
            const dy = enemy.y - food.y;
            const distance = Math.hypot(dx, dy);
            if (distance < enemy.radius + food.radius) {
              enemy.radius += 1;
              foods.splice(j, 1);
              j--;
              setTimeout(() => {
                foods.push({
                  x: Math.random() * 3000,
                  y: Math.random() * 3000,
                  radius: 8,
                  color: 'green',
                  eaten: false
                });
              }, 5000);
            }
          }
          
          // Eat powerups
          for (let j = 0; j < powerups.length; j++) {
            const powerup = powerups[j];
            const dx = enemy.x - powerup.x;
            const dy = enemy.y - powerup.y;
            const distance = Math.hypot(dx, dy);
            if (distance < enemy.radius + powerup.radius) {
              enemy.radius += 2;
              powerups.splice(j, 1);
              j--;
            }
          }
          
          // Eat other enemies
          for (let j = 0; j < enemies.length; j++) {
            if (i === j) continue;
            const other = enemies[j];
            const dx = enemy.x - other.x;
            const dy = enemy.y - other.y;
            const distance = Math.hypot(dx, dy);
            if (distance < enemy.radius + other.radius && enemy.radius > other.radius * 1.1) {
              enemy.radius += Math.floor(other.radius / 2);
              enemies.splice(j, 1);
              if (j < i) i--; // Adjust index
              setTimeout(() => {
                enemies.push({
                  x: Math.random() * 3000,
                  y: Math.random() * 3000,
                  radius: 16,
                  color: 'red',
                  speed: 2 + Math.random(),
                  direction: Math.random() * 2 * Math.PI,
                  detectionRadius: 155 + Math.random() * 50,
                  wanderStart: Date.now(),
                  name: enemyNames[Math.floor(Math.random() * enemyNames.length)],
                  aggressionLevel: Math.random(),
                  memory: [],
                  lastPlayerSeen: null,
                  huntMode: false,
                  fleeMode: false,
                  teamUp: null
                });
              }, 5000);
              break;
            }
          }
        }
      }
      
      function updateCamera() {
        if (gameState === "playing" && player.alive) {
          camera.x = player.x - canvas.width / 2;
          camera.y = player.y - canvas.height / 2;
        } else if (gameState === "spectator" && spectatorTarget) {
          camera.x = spectatorTarget.x - canvas.width / 2;
          camera.y = spectatorTarget.y - canvas.height / 2;
        } else {
          camera.x = 0;
          camera.y = 0;
        }
        camera.x = Math.max(0, Math.min(3000 - canvas.width, camera.x));
        camera.y = Math.max(0, Math.min(3000 - canvas.height, camera.y));
      }
      
      function updateLeaderboardUI() {
        let leaderboardArray = [];
        leaderboardArray.push({ name: playerName, score: score });
        for (let key in remotePlayers) {
          leaderboardArray.push(remotePlayers[key]);
        }
        leaderboardArray.sort((a, b) => (b.score || 0) - (a.score || 0));
        let html = "<h3>Top 5 Players</h3>";
        for (let i = 0; i < Math.min(5, leaderboardArray.length); i++) {
          const entry = leaderboardArray[i];
          html += `<div>${entry.name}: ${entry.score || 0}</div>`;
        }
        document.getElementById('leaderboard').innerHTML = html;
      }
      
      function updatePowerupHUD() {
        document.getElementById('ammoCount').textContent = `Ammo: ${player.ammo}`;
        document.getElementById('powerupStatus').textContent = 
          player.ammo > 0 ? 'Shooter Active' : 'No Power-ups';
      }
      
      function sendChatMessage(msg) {
        if (socket) {
          socket.emit('chatMessage', { name: playerName, message: msg });
        } else {
          addChatMessage(playerName, msg);
        }
      }
      
      function addChatMessage(name, message) {
        const chatLog = document.getElementById('chatLog');
        const messageDiv = document.createElement('div');
        messageDiv.textContent = name + ": " + message;
        chatLog.appendChild(messageDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
      }
      
      function drawEmote(x, y, emote, radius) {
        ctx.font = "24px 'Press Start 2P'";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(emote, x, y - radius - 20);
      }
      
      function drawGame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (backgroundImage.complete) {
          const pattern = ctx.createPattern(backgroundImage, 'repeat');
          if (pattern.setTransform) {
            pattern.setTransform(new DOMMatrix().translate(-camera.x, -camera.y));
          }
          ctx.fillStyle = pattern;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        updateCamera();
        
        // Draw remote players
        for (let key in remotePlayers) {
          const rp = remotePlayers[key];
          if (!rp.alive) continue;
          
          // Draw shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(rp.x - camera.x, rp.y - camera.y + rp.radius + 5, rp.radius * 0.8, rp.radius * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          if (playerSprite.complete) {
            ctx.drawImage(playerSprite, rp.x - camera.x - rp.radius, rp.y - camera.y - rp.radius, rp.radius * 2, rp.radius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(rp.x - camera.x, rp.y - camera.y, rp.radius, 0, Math.PI * 2);
            ctx.fillStyle = "blue";
            ctx.fill();
            ctx.closePath();
          }
          
          // Name with shadow
          ctx.font = "14px 'Press Start 2P'";
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.textAlign = "center";
          ctx.fillText(rp.name, rp.x - camera.x + 1, rp.y - camera.y - rp.radius - 8);
          ctx.fillStyle = "#fff";
          ctx.fillText(rp.name, rp.x - camera.x, rp.y - camera.y - rp.radius - 10);
        }
        
        // Draw local player
        if (gameState === "playing" && player.alive) {
          // Draw shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.beginPath();
          ctx.ellipse(player.x - camera.x, player.y - camera.y + player.radius + 5, player.radius * 0.8, player.radius * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Add glow effect for player
          ctx.shadowColor = '#4a9eff';
          ctx.shadowBlur = 15;
          
          if (playerSprite.complete) {
            ctx.drawImage(playerSprite, player.x - camera.x - player.radius, player.y - camera.y - player.radius, player.radius * 2, player.radius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(player.x - camera.x, player.y - camera.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.closePath();
          }
          
          ctx.shadowBlur = 0;
          
          // Name with shadow and glow
          ctx.font = "14px 'Press Start 2P'";
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.textAlign = "center";
          ctx.fillText(playerName, player.x - camera.x + 1, player.y - camera.y - player.radius - 8);
          ctx.fillStyle = "#4a9eff";
          ctx.shadowColor = '#4a9eff';
          ctx.shadowBlur = 8;
          ctx.fillText(playerName, player.x - camera.x, player.y - camera.y - player.radius - 10);
          ctx.shadowBlur = 0;
          
          if (player.currentEmote && Date.now() - player.emoteTimestamp < 3000) {
            drawEmote(player.x - camera.x, player.y - camera.y, player.currentEmote, player.radius);
          }
        } else if (gameState === "spectator") {
          ctx.font = "20px 'Press Start 2P'";
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.textAlign = "center";
          ctx.fillText("Spectating", canvas.width / 2 + 2, 52);
          ctx.fillText("Press M to return to menu", canvas.width / 2 + 2, 82);
          ctx.fillStyle = "#fff";
          ctx.shadowColor = '#4a9eff';
          ctx.shadowBlur = 10;
          ctx.fillText("Spectating", canvas.width / 2, 50);
          ctx.fillText("Press M to return to menu", canvas.width / 2, 80);
          ctx.shadowBlur = 0;
        }
        
        // Draw enemies
        for (let enemy of enemies) {
          // Draw shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.beginPath();
          ctx.ellipse(enemy.x - camera.x, enemy.y - camera.y + enemy.radius + 5, enemy.radius * 0.8, enemy.radius * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Add menacing glow for larger enemies or hunt mode
          if (enemy.radius > 20 || enemy.huntMode) {
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10 + (enemy.huntMode ? 5 : 0);
          }
          
          if (enemySprite.complete) {
            ctx.drawImage(enemySprite, enemy.x - camera.x - enemy.radius, enemy.y - camera.y - enemy.radius, enemy.radius * 2, enemy.radius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = enemy.huntMode ? '#ff0000' : enemy.color;
            ctx.fill();
            ctx.closePath();
          }
          
          ctx.shadowBlur = 0;
          
          // Name with shadow and status indicator
          ctx.font = "12px 'Press Start 2P'";
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.textAlign = "center";
          let nameColor = "#ff6666";
          if (enemy.huntMode) nameColor = "#ff0000";
          if (enemy.fleeMode) nameColor = "#ffaa00";
          
          ctx.fillText(enemy.name, enemy.x - camera.x + 1, enemy.y - camera.y - enemy.radius - 8);
          ctx.fillStyle = nameColor;
          ctx.fillText(enemy.name, enemy.x - camera.x, enemy.y - camera.y - enemy.radius - 10);
        }
        
        // Draw food
        for (let food of foods) {
          if (!food.eaten) {
            // Draw shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(food.x - camera.x, food.y - camera.y + food.radius + 2, food.radius * 0.6, food.radius * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Add sparkle glow
            ctx.shadowColor = '#ffeb3b';
            ctx.shadowBlur = 6;
            
            if (foodSprite.complete) {
              ctx.drawImage(foodSprite, food.x - camera.x - food.radius, food.y - camera.y - food.radius, food.radius * 2, food.radius * 2);
            } else {
              ctx.beginPath();
              ctx.arc(food.x - camera.x, food.y - camera.y, food.radius, 0, Math.PI * 2);
              ctx.fillStyle = food.color;
              ctx.fill();
              ctx.closePath();
            }
            
            ctx.shadowBlur = 0;
          }
        }
        
        // Draw powerups
        for (let powerup of powerups) {
          // Pulsing effect
          let pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
          
          // Draw shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(powerup.x - camera.x, powerup.y - camera.y + powerup.radius + 3, powerup.radius * 0.8, powerup.radius * 0.2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Add glow
          ctx.shadowColor = '#ff00ff';
          ctx.shadowBlur = 15;
          
          if (powerupSprite.complete) {
            let size = powerup.radius * 2 * pulseScale;
            ctx.drawImage(powerupSprite, 
              powerup.x - camera.x - size/2, 
              powerup.y - camera.y - size/2, 
              size, size);
          } else {
            ctx.beginPath();
            ctx.arc(powerup.x - camera.x, powerup.y - camera.y, powerup.radius * pulseScale, 0, Math.PI * 2);
            ctx.fillStyle = '#ff00ff';
            ctx.fill();
            ctx.closePath();
          }
          
          ctx.shadowBlur = 0;
        }
        
        // Draw projectiles
        for (let proj of projectiles) {
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 8;
          
          if (projectileSprite.complete) {
            ctx.drawImage(projectileSprite, 
              proj.x - camera.x - proj.radius, 
              proj.y - camera.y - proj.radius, 
              proj.radius * 2, proj.radius * 2);
          } else {
            ctx.beginPath();
            ctx.arc(proj.x - camera.x, proj.y - camera.y, proj.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff';
            ctx.fill();
            ctx.closePath();
          }
          
          ctx.shadowBlur = 0;
        }
        
        drawMinimap();
        updateLeaderboardUI();
      }
      
      function drawMinimap() {
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        minimapCtx.fillStyle = '#333';
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        const scaleX = minimapCanvas.width / 3000;
        const scaleY = minimapCanvas.height / 3000;
        
        // Player
        minimapCtx.beginPath();
        minimapCtx.arc(player.x * scaleX, player.y * scaleY, Math.max(2, player.radius * scaleX), 0, Math.PI * 2);
        minimapCtx.fillStyle = player.color;
        minimapCtx.fill();
        minimapCtx.closePath();
        
        // Food
        for (let food of foods) {
          if (!food.eaten) {
            minimapCtx.beginPath();
            minimapCtx.arc(food.x * scaleX, food.y * scaleY, Math.max(1, food.radius * scaleX), 0, Math.PI * 2);
            minimapCtx.fillStyle = food.color;
            minimapCtx.fill();
            minimapCtx.closePath();
          }
        }
        
        // Enemies
        for (let enemy of enemies) {
          minimapCtx.beginPath();
          minimapCtx.arc(enemy.x * scaleX, enemy.y * scaleY, Math.max(2, enemy.radius * scaleX), 0, Math.PI * 2);
          minimapCtx.fillStyle = enemy.huntMode ? '#ff0000' : enemy.color;
          minimapCtx.fill();
          minimapCtx.closePath();
        }
        
        // Powerups
        for (let powerup of powerups) {
          minimapCtx.beginPath();
          minimapCtx.arc(powerup.x * scaleX, powerup.y * scaleY, Math.max(2, powerup.radius * scaleX), 0, Math.PI * 2);
          minimapCtx.fillStyle = '#ff00ff';
          minimapCtx.fill();
          minimapCtx.closePath();
        }
      }
      
      function gameLoop() {
        if (gameState === "playing" && player.alive) {
          handleDash();
          movePlayer();
          detectPlayerCollisions();
        }
        
        updateEnemyAI();
        simulateEnemyConsumption();
        updateProjectiles();
        
        drawGame();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
      
      function resetGame() {
        player.x = 3000 / 2;
        player.y = 3000 / 2;
        player.radius = 16;
        player.isDashing = false;
        player.reloadTimeStart = Date.now();
        player.currentEmote = null;
        player.emoteTimestamp = 0;
        player.alive = true;
        player.ammo = 0;
        player.lastDirection = { x: 1, y: 0 };
        foods = [];
        enemies = [];
        powerups = [];
        projectiles = [];
        keys = {};
        generateFood();
        generateEnemies();
        updatePowerupHUD();
      }
      
      // Chat input event
      document.getElementById('chatInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const msg = e.target.value;
          if (msg.trim() !== "") {
            sendChatMessage(msg);
          }
          e.target.value = "";
        }
      });
      
      // Emote buttons
      document.querySelectorAll('.emoteBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          player.currentEmote = btn.textContent;
          player.emoteTimestamp = Date.now();
        });
      });
      
      document.getElementById('startButton').addEventListener('click', () => {
        const nameInput = document.getElementById('playerNameInput').value.trim();
        if (nameInput !== "") {
          playerName = nameInput;
        }
        document.getElementById('homeMenu').style.display = 'none';
        resetGame();
        score = 0;
        gameState = "playing";
        spectatorTarget = null;
        if (!gameLoopId) gameLoop();
      });
      
    }); // End DOMContentLoaded
  </script>
</body>
</html>
